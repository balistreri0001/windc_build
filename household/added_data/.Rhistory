quit()
reticulate::repl_python()
import subprocess
import sys
subprocess.check_call([sys.executable, "-m", "pip", "install",
"git+https://github.com/USEPA/flowsa.git@ghgi-recursive-yaml#"
"egg=flowsa"])
Y
packages = c("httr","RJSONIO","tidyr","RCurl","ggplot2","SAScii","maps",
"RColorBrewer","dplyr","matrixStats","bea.R","mapproj","devtools")
# packages used by sage but not currently on the system
new.packages = packages[!(packages %in% installed.packages()[,"Package"])]
# install the required packages not already installed
if (length(new.packages))
install.packages(new.packages, repos = "http://cran.rstudio.com/")
# required: gdxrrw
library("devtools")
install_github("GAMS-dev/gdxrrw/gdxrrw@v1.0.10")
library(devtools)
devtools::install_github("wmurphyrd/fiftystater"))
devtools::install_github("wmurphyrd/fiftystater")
setwd("~/git/windc_build/household/added_data")
# install needed packages
list.of.packages <-
c("tidyverse","cpsR","survey","bea.R")
new.packages <-
list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages))
install.packages(new.packages, repos = "http://cran.rstudio.com/")
lapply(list.of.packages, library, character.only = TRUE)
# ------------------------------------------------------------------------------
# pull in cps data
# ------------------------------------------------------------------------------
# years of needed data (asec does not exist prior to 2001. estimates from
# datasets between 2001 and 2004 are estimated.)
years = 2000:2021
# pick income upper bounds for categories to generate population information
upper_bounds = c(25000, 50000, 75000, 150000, Inf)
# cps and bea api keys
cps.key = "a69b1c9f95e30d420fcef94d191d649a340ca7f3"
bea.key = "12C8FE9E-DF75-4515-B170-296AB4E9AB93"
# income variables pre 2019 (retirement income variables redefined in 2019)
cps.vars.pre2019 = c("hwsval",  # "wages and salaries"
"hseval",  # "self-employment (nonfarm)"
"hfrval",  # "self-employment farm"
"hucval",  # "unemployment compensation"
"hwcval",  # "workers compensation"
"hssval",  # "social security"
"hssival", # "supplemental security"
"hpawval", # "public assistance or welfare"
"hvetval", # "veterans benefits"
"hsurval", # "survivors income"
"hdisval", # "disability"
"hretval", # "retirement income"
"hintval", # "interest"
"hdivval", # "dividends"
"hrntval", # "rents"
"hedval",  # "educational assistance"
"hcspval", # "child support"
"hfinval", # "financial assistance"
"hoival",  # "other income"
"htotval") # "total household income
# income variables post 2019 (retirement income variables redefined in 2019)
cps.vars.post2019 = c("hwsval",  # "wages and salaries"
"hseval",  # "self-employment (nonfarm)"
"hfrval",  # "self-employment farm"
"hucval",  # "unemployment compensation"
"hwcval",  # "workers compensation"
"hssval",  # "social security"
"hssival", # "supplemental security"
"hpawval", # "public assistance or welfare"
"hvetval", # "veterans benefits"
"hsurval", # "survivors income"
"hdisval", # "disability"
"hdstval", # "retirement distributions"
"hpenval", # "pension income"
"hannval", # "annuities"
"hintval", # "interest"
"hdivval", # "dividends"
"hrntval", # "rents"
"hedval",  # "educational assistance"
"hcspval", # "child support"
"hfinval", # "financial assistance"
"hoival",  # "other income"
"htotval") # "total household income
# added variables for weighting
cps.rw =   c("gestfips", # state fips
"a_exprrp", # expanded relationship code
"h_hhtype", # type of household interview
"pppos",    # person identifier
"marsupwt") # asec supplement final weight
# first verify that sum of income categories equals total household
# income (commented out)
# year = 2021
# cpsasec <- get_asec(year+1, vars = c(cps.vars.post2019,cps.rw), key = cps.key, tibble=FALSE)
# cpsasec.total <- subset(cpsasec, select = c(htotval))
# cpsasec.cat <- subset(cpsasec, select = c(cps.vars.post2019))
# cpsasec.cat <- subset(cpsasec.cat, select = c(-htotval)) %>%
#    mutate(htotval_dis = rowSums(across())) %>%
#    select(htotval_dis)
# cpsasec.total = cbind(cpsasec.total,cpsasec.cat)
# cpsasec.total$diff = cpsasec.total$htotval - cpsasec.total$htotval_dis
# cpsasec.total$pct = 100 * cpsasec.total$diff / cpsasec.total$htotval
# max(cpsasec.total$pct)
## return the total reported income and share of total by income quantile for the
## specified year
get.shares = function(year) {
# download and process the cps march supplement for the year after requested
# since income questions on the supplement are for the previous year
if (year < 2018) {
cpsasec <- get_asec(year+1, vars = c(cps.vars.pre2019,cps.rw), key = cps.key, tibble=FALSE)
} else {
cpsasec <- get_asec(year+1, vars = c(cps.vars.post2019,cps.rw), key = cps.key, tibble=FALSE)
}
# add column for aggregate retirement distributions to align datasets
if (year >= 2018) {
cpsasec$hretval = cpsasec$hdstval + cpsasec$hpenval + cpsasec$hannval
cps.vars.post2019.add = c(cps.vars.post2019,"hretval")
}
# extract the household file with representative persons
cpsasec = cpsasec[cpsasec$a_exprrp %in% c(1,2) & cpsasec$h_hhtype==1,]
# extract the household file with representative persons
cpsasec = cpsasec[cpsasec$pppos==41,]
# survey design based on the replicate weights
# svy = svrepdesign(data=cpsasec,weight=~marsupwt,repweights='pwwgt[0-9]+',
#                   type='JK1',scale=4/60,rscales=rep(1, 161),mse=TRUE)
# add household label to each entry
bounds <- c(-Inf,upper_bounds)
for (i in 1:length(bounds))
cpsasec$hh[cpsasec$htotval>bounds[i] &
cpsasec$htotval<=bounds[i+1]] = paste0("hh",i)
# scale income levels by the household weight
if (year < 2018) {
for (source in cps.vars.pre2019)
cpsasec[,source] = cpsasec[,source]*cpsasec$marsupwt
} else {
for (source in cps.vars.post2019.add)
cpsasec[,source] = cpsasec[,source]*cpsasec$marsupwt
}
# count observations in sample by quantile and state fips
count <- cpsasec[,c("gestfips","hh")] %>% count(hh,gestfips)
names(count)[2] <- "state"
nat_count <- cpsasec[,c("gestfips","hh")] %>% count(hh)
nat_count$state <- 0
nat_count <- nat_count[,names(count)]
count <- rbind(nat_count,count)
# aggregate income by quantile and state fips
if (year < 2018) {
income = aggregate(
cpsasec[,cps.vars.pre2019],by=list(hh=cpsasec$hh,state=cpsasec$gestfips),sum)
nat_income = aggregate(
cpsasec[,cps.vars.pre2019],by=list(hh=cpsasec$hh),sum)
} else {
income = aggregate(
cpsasec[,cps.vars.post2019.add],by=list(hh=cpsasec$hh,state=cpsasec$gestfips),sum)
nat_income = aggregate(
cpsasec[,cps.vars.post2019.add],by=list(hh=cpsasec$hh),sum)
}
nat_income$state = 0
nat_income = nat_income[,names(income)]
income = rbind(nat_income,income)
# convert income by quantile to share of total by state and quantile
shares <- data.frame(income %>% group_by(state) %>%
mutate(across(-c(hh), ~./sum(.))))
# shift from wide to long format
income = income %>% pivot_longer(!c(state,hh), names_to = "source", values_to = "value")
shares = shares %>% pivot_longer(!c(state,hh), names_to = "source", values_to = "value")
# add the data year
income$year = year
shares$year = year
count$year = year
# function returns list of outputs
return(list(income=income,shares=shares,count=count))
}
# mapping fips to state names
fips <- data.frame(
state = c("0","1","2","4","5","6","8","9","10","11","12","13","15","16","17",
"18","19","20","21","22","23","24","25","26","27","28","29","30",
"31","32","33","34","35","36","37","38","39","40","41","42","44",
"45","46","47","48","49","50","51","53","54","55","56"),
sname = c("united states","alabama","alaska","arizona","arkansas","california",
"colorado","connecticut","delaware","district of columbia","florida",
"georgia","hawaii","idaho","illinois","indiana","iowa","kansas",
"kentucky","louisiana","maine","maryland","massachusetts","michigan",
"minnesota","mississippi","missouri","montana","nebraska","nevada",
"new hampshire","new jersey","new mexico","new york","north carolina",
"north dakota","ohio","oklahoma","oregon","pennsylvania","rhode island",
"south carolina","south dakota","tennessee","texas","utah","vermont",
"virginia","washington","west virginia","wisconsin","wyoming"))
## for each requested year get the income totals, shares, and counts by quantile
## and state
income = NULL
shares = NULL
count = NULL
for (year in years) {
output = get.shares(year)
income = rbind(income,output[["income"]])
shares = rbind(shares,output[["shares"]])
count = rbind(count,output[["count"]])
}
## merge state names into income and shares data.frames
shares$state <- as.character(shares$state)
income$state <- as.character(income$state)
count$state <- as.character(count$state)
income <- left_join(income, fips, by="state")
shares <- left_join(shares, fips, by="state")
count <- left_join(count, fips, by="state")
cps.vars.plot = rbind(
c("hretval","retirement income"),
c("hdstval","retirement distributions"),
c("hpenval","pension income"),
c("hannval","annuities"))
cps.vars.plot = data.frame(source=cps.vars.plot[,1],
description=cps.vars.plot[,2],
stringsAsFactors=FALSE)
# add the income source descriptions
shares_plot = left_join(subset(shares,source %in% cps.vars.plot$source),
cps.vars.plot,by="source")
income_plot = left_join(subset(income,source %in% cps.vars.plot$source),
cps.vars.plot,by="source")
# set the ordering for the plot
shares_plot$description = factor(shares_plot$description,
rev(cps.vars.plot$description))
shares_plot$year = factor(shares_plot$year)
income_plot$description = factor(income_plot$description,
rev(cps.vars.plot$description))
income_plot$year = factor(income_plot$year)
categories <- factor(c("hh1","hh2","hh3","hh4","hh5"))
shares_plot$hh = factor(shares_plot$hh,rev(levels(categories)))
shares_plot$sname = factor(shares_plot$sname)
income_plot$hh = factor(incomes_plot$hh,rev(levels(categories)))
income_plot$sname = factor(income_plot$sname)
state_shares <- subset(shares_plot, state %in% "0")
state_income <- subset(income_plot, state %in% "0")
p = ggplot(state_shares)+
geom_bar(aes(y=year,x=value,fill=hh),stat="identity")+
scale_fill_brewer(palette="Set3") +
facet_grid(sname~description, scales="free") +
labs(y="Year",x="Share of Total") +
#  xlim(0,1) +
guides(fill=guide_legend(title="Household Categories",reverse=TRUE))+
theme(axis.line.x      = element_line(colour="black"),
axis.line.y      = element_line(colour="black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border     = element_blank(),
panel.background = element_blank(),
legend.box.just  = "left",
legend.key       = element_blank())
print(p)
p = ggplot(state_income)+
geom_bar(aes(y=year,x=value/1e9,fill=hh),stat="identity")+
scale_fill_brewer(palette="Set3") +
facet_grid(sname~description, scales="fixed") +
labs(y="Year",x="billions $") +
#  xlim(0,1) +
guides(fill=guide_legend(title="Household Categories",reverse=TRUE))+
theme(axis.line.x      = element_line(colour="black"),
axis.line.y      = element_line(colour="black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border     = element_blank(),
panel.background = element_blank(),
legend.box.just  = "left",
legend.key       = element_blank())
print(p)
write.csv(income,
paste0("cps_asec_income_totals_",min(years),"_",max(years),".csv"),
row.names=F)
# income shares
write.csv(shares,
paste0("cps_asec_income_shares_",min(years),"_",max(years),".csv"),
row.names=F)
# count of observations
write.csv(count,
paste0("cps_asec_income_counts_",min(years),"_",max(years),".csv"),
row.names=F)
specs <- list(
'UserID' = bea.key,
'Method' = 'GetData',
'datasetname' = 'NIPA',
'TableName' = 'T20100',
'Frequency' = 'A',
'Year' = '2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021',
'ResultFormat' = 'json'
)
beadata <- data.frame(beaGet(specs))
# convert data to long format
beadata <- pivot_longer(
beadata,
-c(TableName,SeriesCode,LineNumber,LineDescription,METRIC_NAME,CL_UNIT,UNIT_MULT),
names_to = "year", values_to = "value")
beadata$year = as.numeric(str_replace(beadata$year,"DataValue_",""))
# keep all data, using gams to piece together needed components
write.csv(beadata, "nipa_income_outlays_2000_2021.csv", row.names=FALSE)
system('gdxdump ../../core/WiNDCdatabase.gdx output=ld0_windc.csv symb=ld0_ format=csv')
system('gdxdump ../../core/WiNDCdatabase.gdx output=kd0_windc.csv symb=kd0_ format=csv')
abbr <- data.frame(
r = c("US","AL","AK","AZ","AR","CA","CO","CT","DE","DC","FL","GA","HI","ID","IL",
"IN","IA","KS","KY","LA","ME","MD","MA","MI","MN","MS","MO","MT",
"NE","NV","NH","NJ","NM","NY","NC","ND","OH","OK","OR","PA","RI",
"SC","SD","TN","TX","UT","VT","VA","WA","WV","WI","WY"),
sname = c("united states","alabama","alaska","arizona","arkansas","california",
"colorado","connecticut","delaware","district of columbia","florida",
"georgia","hawaii","idaho","illinois","indiana","iowa","kansas",
"kentucky","louisiana","maine","maryland","massachusetts","michigan",
"minnesota","mississippi","missouri","montana","nebraska","nevada",
"new hampshire","new jersey","new mexico","new york","north carolina",
"north dakota","ohio","oklahoma","oregon","pennsylvania","rhode island",
"south carolina","south dakota","tennessee","texas","utah","vermont",
"virginia","washington","west virginia","wisconsin","wyoming"))
ld0 = read.csv(file=file.path("ld0_windc.csv")) %>%
group_by(yr,r) %>%
summarize(value = sum(Val,na.rm=TRUE)*1e9) %>%
rename("year"="yr") %>%
left_join(abbr)
kd0 = read.csv(file=file.path("kd0_windc.csv")) %>%
group_by(yr,r) %>%
summarize(value = sum(Val,na.rm=TRUE)*1e9) %>%
rename("year"="yr") %>%
left_join(abbr)
ld0_windc = ld0 %>% group_by(year) %>% summarize(windc_labor = sum(value))
kd0_windc = kd0 %>% group_by(year) %>% summarize(windc_capital = sum(value))
cps_totals = subset(income, state %in% 0) %>%
group_by(year,source) %>%
summarize(cps_value = sum(value))
nipa_cps_totinc = subset(beadata, LineNumber %in% "1") %>%
rename("nipa_totinc"="value","desc"="LineDescription") %>%
select(year,desc,nipa_totinc) %>%
mutate(nipa_totinc = nipa_totinc * 1e6) %>%
left_join(subset(cps_totals, source %in% "htotval")) %>%
mutate(pct_diff = 100 * (cps_value / nipa_totinc - 1))
nipa_windc_labor = subset(beadata, LineNumber %in% "2") %>%
rename("nipa_labor"="value", "desc"="LineDescription") %>%
select(year,desc,nipa_labor) %>%
mutate(nipa_labor = nipa_labor * 1e6) %>%
left_join(ld0_windc) %>%
mutate(pct_diff = 100 * (windc_labor / nipa_labor - 1))
list.of.packages <-
c("tidyverse","cpsR","survey","bea.R","rmarkdown")
new.packages <-
list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages))
install.packages(new.packages, repos = "http://cran.rstudio.com/")
lapply(list.of.packages, library, character.only = TRUE)
list.of.packages <-
c("tidyverse","cpsR","survey","bea.R","distill","rticle")
new.packages <-
list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages))
install.packages(new.packages, repos = "http://cran.rstudio.com/")
lapply(list.of.packages, library, character.only = TRUE)
install.packages(new.packages, repos = "http://cran.rstudio.com/")
list.of.packages <-
c("tidyverse","cpsR","survey","bea.R","distill","rticles")
new.packages <-
list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages))
install.packages(new.packages, repos = "http://cran.rstudio.com/")
lapply(list.of.packages, library, character.only = TRUE)
unlink("~/git/beige_model/beige_cache", recursive = TRUE)
list.of.packages <-
c("rmarkdown","distill","rticles","papaja")
new.packages <-
list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages))
install.packages(new.packages, repos = "http://cran.rstudio.com/")
lapply(list.of.packages, library, character.only = TRUE)
